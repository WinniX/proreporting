/*
 * apaleo Booking API
 *
 * Resources and methods to manage guest journeys.
 *
 * API version: v1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bookingclient

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ReservationActionsApiService ReservationActionsApi service
type ReservationActionsApiService service

type ApiBookingReservationActionsByIdAddCityTaxPutRequest struct {
	ctx _context.Context
	ApiService *ReservationActionsApiService
	id string
}


func (r ApiBookingReservationActionsByIdAddCityTaxPutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.BookingReservationActionsByIdAddCityTaxPutExecute(r)
}

/*
 * BookingReservationActionsByIdAddCityTaxPut Adds the city tax to a reservation.
 * Use this if you want to add the city tax to a reservation.<br>You must have this scope: 'reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation.
 * @return ApiBookingReservationActionsByIdAddCityTaxPutRequest
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdAddCityTaxPut(ctx _context.Context, id string) ApiBookingReservationActionsByIdAddCityTaxPutRequest {
	return ApiBookingReservationActionsByIdAddCityTaxPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdAddCityTaxPutExecute(r ApiBookingReservationActionsByIdAddCityTaxPutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationActionsApiService.BookingReservationActionsByIdAddCityTaxPut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservation-actions/{id}/add-city-tax"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBookingReservationActionsByIdAmendPutRequest struct {
	ctx _context.Context
	ApiService *ReservationActionsApiService
	id string
	body *DesiredStayDetailsModel
}

func (r ApiBookingReservationActionsByIdAmendPutRequest) Body(body DesiredStayDetailsModel) ApiBookingReservationActionsByIdAmendPutRequest {
	r.body = &body
	return r
}

func (r ApiBookingReservationActionsByIdAmendPutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.BookingReservationActionsByIdAmendPutExecute(r)
}

/*
 * BookingReservationActionsByIdAmendPut Allows you to amend the stay details of a reservation
 * Modifies the stay-related data of a reservation.<br />
If a reservation is 'Confirmed', you can change all fields.<br />
If a reservation is 'InHouse', only changes to future time slices are possible.<br />
Changes to reservations that are in the status 'CheckedOut' or 'Canceled' are not possible at all.<br>You must have this scope: 'reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation that should be modified
 * @return ApiBookingReservationActionsByIdAmendPutRequest
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdAmendPut(ctx _context.Context, id string) ApiBookingReservationActionsByIdAmendPutRequest {
	return ApiBookingReservationActionsByIdAmendPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdAmendPutExecute(r ApiBookingReservationActionsByIdAmendPutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationActionsApiService.BookingReservationActionsByIdAmendPut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservation-actions/{id}/amend"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBookingReservationActionsByIdAmendforcePutRequest struct {
	ctx _context.Context
	ApiService *ReservationActionsApiService
	id string
	body *DesiredStayDetailsModel
}

func (r ApiBookingReservationActionsByIdAmendforcePutRequest) Body(body DesiredStayDetailsModel) ApiBookingReservationActionsByIdAmendforcePutRequest {
	r.body = &body
	return r
}

func (r ApiBookingReservationActionsByIdAmendforcePutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.BookingReservationActionsByIdAmendforcePutExecute(r)
}

/*
 * BookingReservationActionsByIdAmendforcePut Allows you to amend the stay details of a reservation regardless of availability or restrictions.
 * Modifies the stay-related data of a reservation.<br />
If a reservation is 'Confirmed', you can change all fields.<br />
If a reservation is 'InHouse', only changes to future time slices are possible.<br />
Changes to reservations that are in the status 'CheckedOut' or 'Canceled' are not possible at all.<br>You must have this scope: 'reservations.force-manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation that should be modified
 * @return ApiBookingReservationActionsByIdAmendforcePutRequest
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdAmendforcePut(ctx _context.Context, id string) ApiBookingReservationActionsByIdAmendforcePutRequest {
	return ApiBookingReservationActionsByIdAmendforcePutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdAmendforcePutExecute(r ApiBookingReservationActionsByIdAmendforcePutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationActionsApiService.BookingReservationActionsByIdAmendforcePut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservation-actions/{id}/amend/$force"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBookingReservationActionsByIdAssignUnitByUnitIdPutRequest struct {
	ctx _context.Context
	ApiService *ReservationActionsApiService
	id string
	unitId string
	from *string
	to *string
}

func (r ApiBookingReservationActionsByIdAssignUnitByUnitIdPutRequest) From(from string) ApiBookingReservationActionsByIdAssignUnitByUnitIdPutRequest {
	r.from = &from
	return r
}
func (r ApiBookingReservationActionsByIdAssignUnitByUnitIdPutRequest) To(to string) ApiBookingReservationActionsByIdAssignUnitByUnitIdPutRequest {
	r.to = &to
	return r
}

func (r ApiBookingReservationActionsByIdAssignUnitByUnitIdPutRequest) Execute() (AssignedUnitModel, *_nethttp.Response, error) {
	return r.ApiService.BookingReservationActionsByIdAssignUnitByUnitIdPutExecute(r)
}

/*
 * BookingReservationActionsByIdAssignUnitByUnitIdPut Assign a specific unit to a reservation.
 * Assigns a specific unit to a reservation which is in state 'Confirmed' or 'InHouse'.<br />If the unit is not available, the call will return an error, and no unit will be assigned.<br>You must have at least one of these scopes: 'reservations.assign-unit, reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation the unit should be assigned to.
 * @param unitId The id of the unit to be assigned.
 * @return ApiBookingReservationActionsByIdAssignUnitByUnitIdPutRequest
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdAssignUnitByUnitIdPut(ctx _context.Context, id string, unitId string) ApiBookingReservationActionsByIdAssignUnitByUnitIdPutRequest {
	return ApiBookingReservationActionsByIdAssignUnitByUnitIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		unitId: unitId,
	}
}

/*
 * Execute executes the request
 * @return AssignedUnitModel
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdAssignUnitByUnitIdPutExecute(r ApiBookingReservationActionsByIdAssignUnitByUnitIdPutRequest) (AssignedUnitModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AssignedUnitModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationActionsApiService.BookingReservationActionsByIdAssignUnitByUnitIdPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservation-actions/{id}/assign-unit/{unitId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"unitId"+"}", _neturl.PathEscape(parameterToString(r.unitId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.from != nil {
		localVarQueryParams.Add("from", parameterToString(*r.from, ""))
	}
	if r.to != nil {
		localVarQueryParams.Add("to", parameterToString(*r.to, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBookingReservationActionsByIdAssignUnitPutRequest struct {
	ctx _context.Context
	ApiService *ReservationActionsApiService
	id string
}


func (r ApiBookingReservationActionsByIdAssignUnitPutRequest) Execute() (AutoAssignedUnitListModel, *_nethttp.Response, error) {
	return r.ApiService.BookingReservationActionsByIdAssignUnitPutExecute(r)
}

/*
 * BookingReservationActionsByIdAssignUnitPut Assign a unit to a reservation.
 * Assigns one of the available units to a reservation which is in state 'Confirmed' or 'InHouse'.<br>You must have at least one of these scopes: 'reservations.assign-unit, reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation a unit should be assigned to.
 * @return ApiBookingReservationActionsByIdAssignUnitPutRequest
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdAssignUnitPut(ctx _context.Context, id string) ApiBookingReservationActionsByIdAssignUnitPutRequest {
	return ApiBookingReservationActionsByIdAssignUnitPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return AutoAssignedUnitListModel
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdAssignUnitPutExecute(r ApiBookingReservationActionsByIdAssignUnitPutRequest) (AutoAssignedUnitListModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AutoAssignedUnitListModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationActionsApiService.BookingReservationActionsByIdAssignUnitPut")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservation-actions/{id}/assign-unit"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBookingReservationActionsByIdBookServicePutRequest struct {
	ctx _context.Context
	ApiService *ReservationActionsApiService
	id string
	body *BookReservationServiceModel
}

func (r ApiBookingReservationActionsByIdBookServicePutRequest) Body(body BookReservationServiceModel) ApiBookingReservationActionsByIdBookServicePutRequest {
	r.body = &body
	return r
}

func (r ApiBookingReservationActionsByIdBookServicePutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.BookingReservationActionsByIdBookServicePutExecute(r)
}

/*
 * BookingReservationActionsByIdBookServicePut Book the service for a specific reservation.
 * Use this to book a service for a specific reservation.
Please note that when dates are specified, all desired dates must be specified or they will be removed if not posted to the folio.<br>You must have this scope: 'reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation.
 * @return ApiBookingReservationActionsByIdBookServicePutRequest
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdBookServicePut(ctx _context.Context, id string) ApiBookingReservationActionsByIdBookServicePutRequest {
	return ApiBookingReservationActionsByIdBookServicePutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdBookServicePutExecute(r ApiBookingReservationActionsByIdBookServicePutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationActionsApiService.BookingReservationActionsByIdBookServicePut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservation-actions/{id}/book-service"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBookingReservationActionsByIdCancelPutRequest struct {
	ctx _context.Context
	ApiService *ReservationActionsApiService
	id string
}


func (r ApiBookingReservationActionsByIdCancelPutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.BookingReservationActionsByIdCancelPutExecute(r)
}

/*
 * BookingReservationActionsByIdCancelPut Cancel a reservation.
 * Cancel a specific reservation which is in status 'Confirmed' and where the arrival time is in the future.
This changes the status to 'Canceled', and sets the cancellation date and time.<br>You must have this scope: 'reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation that should be processed.
 * @return ApiBookingReservationActionsByIdCancelPutRequest
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdCancelPut(ctx _context.Context, id string) ApiBookingReservationActionsByIdCancelPutRequest {
	return ApiBookingReservationActionsByIdCancelPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdCancelPutExecute(r ApiBookingReservationActionsByIdCancelPutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationActionsApiService.BookingReservationActionsByIdCancelPut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservation-actions/{id}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBookingReservationActionsByIdCheckinPutRequest struct {
	ctx _context.Context
	ApiService *ReservationActionsApiService
	id string
	withCityTax *bool
}

func (r ApiBookingReservationActionsByIdCheckinPutRequest) WithCityTax(withCityTax bool) ApiBookingReservationActionsByIdCheckinPutRequest {
	r.withCityTax = &withCityTax
	return r
}

func (r ApiBookingReservationActionsByIdCheckinPutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.BookingReservationActionsByIdCheckinPutExecute(r)
}

/*
 * BookingReservationActionsByIdCheckinPut Check-in of a reservation.
 * Check in a specific reservation which is in status 'Confirmed', and has a unit assigned. This changes the status to 'InHouse', and sets the check-in date and time.<br>You must have this scope: 'reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation that should be processed.
 * @return ApiBookingReservationActionsByIdCheckinPutRequest
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdCheckinPut(ctx _context.Context, id string) ApiBookingReservationActionsByIdCheckinPutRequest {
	return ApiBookingReservationActionsByIdCheckinPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdCheckinPutExecute(r ApiBookingReservationActionsByIdCheckinPutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationActionsApiService.BookingReservationActionsByIdCheckinPut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservation-actions/{id}/checkin"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.withCityTax != nil {
		localVarQueryParams.Add("withCityTax", parameterToString(*r.withCityTax, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBookingReservationActionsByIdCheckoutPutRequest struct {
	ctx _context.Context
	ApiService *ReservationActionsApiService
	id string
}


func (r ApiBookingReservationActionsByIdCheckoutPutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.BookingReservationActionsByIdCheckoutPutExecute(r)
}

/*
 * BookingReservationActionsByIdCheckoutPut Check-out of a reservation.
 * Check out a specific reservation which is in status 'InHouse'. This changes the status to 'CheckedOut', and sets the check-out date and time.
All open charges on the folio will be posted.
<br />
Check-out is only possible, if the departure date is not later than tomorrow. Otherwise, first amend the reservation and shorten the stay.<br>You must have this scope: 'reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation that should be processed.
 * @return ApiBookingReservationActionsByIdCheckoutPutRequest
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdCheckoutPut(ctx _context.Context, id string) ApiBookingReservationActionsByIdCheckoutPutRequest {
	return ApiBookingReservationActionsByIdCheckoutPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdCheckoutPutExecute(r ApiBookingReservationActionsByIdCheckoutPutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationActionsApiService.BookingReservationActionsByIdCheckoutPut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservation-actions/{id}/checkout"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBookingReservationActionsByIdNoshowPutRequest struct {
	ctx _context.Context
	ApiService *ReservationActionsApiService
	id string
}


func (r ApiBookingReservationActionsByIdNoshowPutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.BookingReservationActionsByIdNoshowPutExecute(r)
}

/*
 * BookingReservationActionsByIdNoshowPut Set a reservation to No-show.
 * Set a specific reservation to No-show which is in status 'Confirmed' and where the arrival date is in the past.
This changes the status to 'NoShow', and sets the no-show date and time.<br>You must have this scope: 'reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation that should be processed.
 * @return ApiBookingReservationActionsByIdNoshowPutRequest
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdNoshowPut(ctx _context.Context, id string) ApiBookingReservationActionsByIdNoshowPutRequest {
	return ApiBookingReservationActionsByIdNoshowPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdNoshowPutExecute(r ApiBookingReservationActionsByIdNoshowPutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationActionsApiService.BookingReservationActionsByIdNoshowPut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservation-actions/{id}/noshow"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBookingReservationActionsByIdRemoveCityTaxPutRequest struct {
	ctx _context.Context
	ApiService *ReservationActionsApiService
	id string
}


func (r ApiBookingReservationActionsByIdRemoveCityTaxPutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.BookingReservationActionsByIdRemoveCityTaxPutExecute(r)
}

/*
 * BookingReservationActionsByIdRemoveCityTaxPut Removes the city tax from a reservation.
 * Use this is you want to remove the city tax from a reservation before the stay.<br>You must have this scope: 'reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation.
 * @return ApiBookingReservationActionsByIdRemoveCityTaxPutRequest
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdRemoveCityTaxPut(ctx _context.Context, id string) ApiBookingReservationActionsByIdRemoveCityTaxPutRequest {
	return ApiBookingReservationActionsByIdRemoveCityTaxPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdRemoveCityTaxPutExecute(r ApiBookingReservationActionsByIdRemoveCityTaxPutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationActionsApiService.BookingReservationActionsByIdRemoveCityTaxPut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservation-actions/{id}/remove-city-tax"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBookingReservationActionsByIdUnassignUnitsPutRequest struct {
	ctx _context.Context
	ApiService *ReservationActionsApiService
	id string
}


func (r ApiBookingReservationActionsByIdUnassignUnitsPutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.BookingReservationActionsByIdUnassignUnitsPutExecute(r)
}

/*
 * BookingReservationActionsByIdUnassignUnitsPut Unassign units from a reservation.
 * Unassigns units for all time slices of the given reservation. If no units are assigned for the
reservation nothing will happen. It will fail for reservations in status 'CheckedOut'.<br>You must have at least one of these scopes: 'reservations.assign-unit, reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation the unit should be unassigned for.
 * @return ApiBookingReservationActionsByIdUnassignUnitsPutRequest
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdUnassignUnitsPut(ctx _context.Context, id string) ApiBookingReservationActionsByIdUnassignUnitsPutRequest {
	return ApiBookingReservationActionsByIdUnassignUnitsPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ReservationActionsApiService) BookingReservationActionsByIdUnassignUnitsPutExecute(r ApiBookingReservationActionsByIdUnassignUnitsPutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationActionsApiService.BookingReservationActionsByIdUnassignUnitsPut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservation-actions/{id}/unassign-units"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
