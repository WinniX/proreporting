/*
 * apaleo Booking API
 *
 * Resources and methods to manage guest journeys.
 *
 * API version: v1
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package bookingclient

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// ReservationApiService ReservationApi service
type ReservationApiService service

type ApiBookingReservationsByIdGetRequest struct {
	ctx _context.Context
	ApiService *ReservationApiService
	id string
	expand *[]string
}

func (r ApiBookingReservationsByIdGetRequest) Expand(expand []string) ApiBookingReservationsByIdGetRequest {
	r.expand = &expand
	return r
}

func (r ApiBookingReservationsByIdGetRequest) Execute() (ReservationModel, *_nethttp.Response, error) {
	return r.ApiService.BookingReservationsByIdGetExecute(r)
}

/*
 * BookingReservationsByIdGet Returns a specific reservation.
 * Retrieves a reservation, specified by its ID.<br>You must have at least one of these scopes: 'reservations.read, reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation to be retrieved.
 * @return ApiBookingReservationsByIdGetRequest
 */
func (a *ReservationApiService) BookingReservationsByIdGet(ctx _context.Context, id string) ApiBookingReservationsByIdGetRequest {
	return ApiBookingReservationsByIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return ReservationModel
 */
func (a *ReservationApiService) BookingReservationsByIdGetExecute(r ApiBookingReservationsByIdGetRequest) (ReservationModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReservationModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.BookingReservationsByIdGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.expand != nil {
		localVarQueryParams.Add("expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBookingReservationsByIdOffersGetRequest struct {
	ctx _context.Context
	ApiService *ReservationApiService
	id string
	arrival *string
	departure *string
	adults *int32
	childrenAges *[]int32
	channelCode *string
	promoCode *string
	requote *bool
	includeUnavailable *bool
}

func (r ApiBookingReservationsByIdOffersGetRequest) Arrival(arrival string) ApiBookingReservationsByIdOffersGetRequest {
	r.arrival = &arrival
	return r
}
func (r ApiBookingReservationsByIdOffersGetRequest) Departure(departure string) ApiBookingReservationsByIdOffersGetRequest {
	r.departure = &departure
	return r
}
func (r ApiBookingReservationsByIdOffersGetRequest) Adults(adults int32) ApiBookingReservationsByIdOffersGetRequest {
	r.adults = &adults
	return r
}
func (r ApiBookingReservationsByIdOffersGetRequest) ChildrenAges(childrenAges []int32) ApiBookingReservationsByIdOffersGetRequest {
	r.childrenAges = &childrenAges
	return r
}
func (r ApiBookingReservationsByIdOffersGetRequest) ChannelCode(channelCode string) ApiBookingReservationsByIdOffersGetRequest {
	r.channelCode = &channelCode
	return r
}
func (r ApiBookingReservationsByIdOffersGetRequest) PromoCode(promoCode string) ApiBookingReservationsByIdOffersGetRequest {
	r.promoCode = &promoCode
	return r
}
func (r ApiBookingReservationsByIdOffersGetRequest) Requote(requote bool) ApiBookingReservationsByIdOffersGetRequest {
	r.requote = &requote
	return r
}
func (r ApiBookingReservationsByIdOffersGetRequest) IncludeUnavailable(includeUnavailable bool) ApiBookingReservationsByIdOffersGetRequest {
	r.includeUnavailable = &includeUnavailable
	return r
}

func (r ApiBookingReservationsByIdOffersGetRequest) Execute() (ReservationStayOffersModel, *_nethttp.Response, error) {
	return r.ApiService.BookingReservationsByIdOffersGetExecute(r)
}

/*
 * BookingReservationsByIdOffersGet Returns offers for one specific reservation.
 * Calculates and returns offers for amending a specific reservation.<br>You must have at least one of these scopes: 'offers.read, reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation to be amended.
 * @return ApiBookingReservationsByIdOffersGetRequest
 */
func (a *ReservationApiService) BookingReservationsByIdOffersGet(ctx _context.Context, id string) ApiBookingReservationsByIdOffersGetRequest {
	return ApiBookingReservationsByIdOffersGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return ReservationStayOffersModel
 */
func (a *ReservationApiService) BookingReservationsByIdOffersGetExecute(r ApiBookingReservationsByIdOffersGetRequest) (ReservationStayOffersModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReservationStayOffersModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.BookingReservationsByIdOffersGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservations/{id}/offers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.arrival != nil {
		localVarQueryParams.Add("arrival", parameterToString(*r.arrival, ""))
	}
	if r.departure != nil {
		localVarQueryParams.Add("departure", parameterToString(*r.departure, ""))
	}
	if r.adults != nil {
		localVarQueryParams.Add("adults", parameterToString(*r.adults, ""))
	}
	if r.childrenAges != nil {
		localVarQueryParams.Add("childrenAges", parameterToString(*r.childrenAges, "csv"))
	}
	if r.channelCode != nil {
		localVarQueryParams.Add("channelCode", parameterToString(*r.channelCode, ""))
	}
	if r.promoCode != nil {
		localVarQueryParams.Add("promoCode", parameterToString(*r.promoCode, ""))
	}
	if r.requote != nil {
		localVarQueryParams.Add("requote", parameterToString(*r.requote, ""))
	}
	if r.includeUnavailable != nil {
		localVarQueryParams.Add("includeUnavailable", parameterToString(*r.includeUnavailable, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBookingReservationsByIdPatchRequest struct {
	ctx _context.Context
	ApiService *ReservationApiService
	id string
	body *[]Operation
}

func (r ApiBookingReservationsByIdPatchRequest) Body(body []Operation) ApiBookingReservationsByIdPatchRequest {
	r.body = &body
	return r
}

func (r ApiBookingReservationsByIdPatchRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.BookingReservationsByIdPatchExecute(r)
}

/*
 * BookingReservationsByIdPatch Allows to modify certain reservation properties
 * Here is the list of operations that are currently allowed:
- Add, replace and remove Comment
- Add, replace and remove GuestComment
- Add, replace and remove PaymentAccount
- Add, replace and remove TravelPurpose
- Add, replace and remove AdditionalGuests
- Add a company (using company/Id, and only if not already set)
- Add, replace and remove Commission
- Replace PrimaryGuest
- Remove ValidationMessages<br>You must have this scope: 'reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation to be modified.
 * @return ApiBookingReservationsByIdPatchRequest
 */
func (a *ReservationApiService) BookingReservationsByIdPatch(ctx _context.Context, id string) ApiBookingReservationsByIdPatchRequest {
	return ApiBookingReservationsByIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ReservationApiService) BookingReservationsByIdPatchExecute(r ApiBookingReservationsByIdPatchRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.BookingReservationsByIdPatch")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBookingReservationsByIdServiceOffersGetRequest struct {
	ctx _context.Context
	ApiService *ReservationApiService
	id string
	channelCode *string
	onlyDefaultDates *bool
}

func (r ApiBookingReservationsByIdServiceOffersGetRequest) ChannelCode(channelCode string) ApiBookingReservationsByIdServiceOffersGetRequest {
	r.channelCode = &channelCode
	return r
}
func (r ApiBookingReservationsByIdServiceOffersGetRequest) OnlyDefaultDates(onlyDefaultDates bool) ApiBookingReservationsByIdServiceOffersGetRequest {
	r.onlyDefaultDates = &onlyDefaultDates
	return r
}

func (r ApiBookingReservationsByIdServiceOffersGetRequest) Execute() (ServiceOffersModel, *_nethttp.Response, error) {
	return r.ApiService.BookingReservationsByIdServiceOffersGetExecute(r)
}

/*
 * BookingReservationsByIdServiceOffersGet Returns service offers for one specific reservation.
 * Calculates and returns service offers for a specific reservation.<br>You must have at least one of these scopes: 'offers.read, reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation.
 * @return ApiBookingReservationsByIdServiceOffersGetRequest
 */
func (a *ReservationApiService) BookingReservationsByIdServiceOffersGet(ctx _context.Context, id string) ApiBookingReservationsByIdServiceOffersGetRequest {
	return ApiBookingReservationsByIdServiceOffersGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return ServiceOffersModel
 */
func (a *ReservationApiService) BookingReservationsByIdServiceOffersGetExecute(r ApiBookingReservationsByIdServiceOffersGetRequest) (ServiceOffersModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ServiceOffersModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.BookingReservationsByIdServiceOffersGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservations/{id}/service-offers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.channelCode != nil {
		localVarQueryParams.Add("channelCode", parameterToString(*r.channelCode, ""))
	}
	if r.onlyDefaultDates != nil {
		localVarQueryParams.Add("onlyDefaultDates", parameterToString(*r.onlyDefaultDates, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBookingReservationsByIdServicesDeleteRequest struct {
	ctx _context.Context
	ApiService *ReservationApiService
	id string
	serviceId *string
}

func (r ApiBookingReservationsByIdServicesDeleteRequest) ServiceId(serviceId string) ApiBookingReservationsByIdServicesDeleteRequest {
	r.serviceId = &serviceId
	return r
}

func (r ApiBookingReservationsByIdServicesDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.BookingReservationsByIdServicesDeleteExecute(r)
}

/*
 * BookingReservationsByIdServicesDelete Removes a service from a reservation.
 * Removes a service from a reservation. The service will not be removed if it is mandatory, already posted or if the service date is in the past.<br>You must have this scope: 'reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation.
 * @return ApiBookingReservationsByIdServicesDeleteRequest
 */
func (a *ReservationApiService) BookingReservationsByIdServicesDelete(ctx _context.Context, id string) ApiBookingReservationsByIdServicesDeleteRequest {
	return ApiBookingReservationsByIdServicesDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *ReservationApiService) BookingReservationsByIdServicesDeleteExecute(r ApiBookingReservationsByIdServicesDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.BookingReservationsByIdServicesDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservations/{id}/services"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.serviceId == nil {
		return nil, reportError("serviceId is required and must be specified")
	}

	localVarQueryParams.Add("serviceId", parameterToString(*r.serviceId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBookingReservationsByIdServicesGetRequest struct {
	ctx _context.Context
	ApiService *ReservationApiService
	id string
}


func (r ApiBookingReservationsByIdServicesGetRequest) Execute() (ReservationServiceListModel, *_nethttp.Response, error) {
	return r.ApiService.BookingReservationsByIdServicesGetExecute(r)
}

/*
 * BookingReservationsByIdServicesGet Returns the services booked for a specific reservation.
 * Returns the services booked for a specific reservation.<br>You must have at least one of these scopes: 'reservations.read, reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Id of the reservation.
 * @return ApiBookingReservationsByIdServicesGetRequest
 */
func (a *ReservationApiService) BookingReservationsByIdServicesGet(ctx _context.Context, id string) ApiBookingReservationsByIdServicesGetRequest {
	return ApiBookingReservationsByIdServicesGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return ReservationServiceListModel
 */
func (a *ReservationApiService) BookingReservationsByIdServicesGetExecute(r ApiBookingReservationsByIdServicesGetRequest) (ReservationServiceListModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReservationServiceListModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.BookingReservationsByIdServicesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservations/{id}/services"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBookingReservationsGetRequest struct {
	ctx _context.Context
	ApiService *ReservationApiService
	bookingId *string
	propertyIds *[]string
	ratePlanIds *[]string
	companyIds *[]string
	unitIds *[]string
	unitGroupIds *[]string
	unitGroupTypes *[]string
	blockIds *[]string
	status *[]string
	dateFilter *string
	from *time.Time
	to *time.Time
	channelCode *[]string
	sources *[]string
	validationMessageCategory *[]string
	externalCode *string
	textSearch *string
	balanceFilter *[]string
	allFoliosHaveInvoice *bool
	pageNumber *int32
	pageSize *int32
	sort *[]string
	expand *[]string
}

func (r ApiBookingReservationsGetRequest) BookingId(bookingId string) ApiBookingReservationsGetRequest {
	r.bookingId = &bookingId
	return r
}
func (r ApiBookingReservationsGetRequest) PropertyIds(propertyIds []string) ApiBookingReservationsGetRequest {
	r.propertyIds = &propertyIds
	return r
}
func (r ApiBookingReservationsGetRequest) RatePlanIds(ratePlanIds []string) ApiBookingReservationsGetRequest {
	r.ratePlanIds = &ratePlanIds
	return r
}
func (r ApiBookingReservationsGetRequest) CompanyIds(companyIds []string) ApiBookingReservationsGetRequest {
	r.companyIds = &companyIds
	return r
}
func (r ApiBookingReservationsGetRequest) UnitIds(unitIds []string) ApiBookingReservationsGetRequest {
	r.unitIds = &unitIds
	return r
}
func (r ApiBookingReservationsGetRequest) UnitGroupIds(unitGroupIds []string) ApiBookingReservationsGetRequest {
	r.unitGroupIds = &unitGroupIds
	return r
}
func (r ApiBookingReservationsGetRequest) UnitGroupTypes(unitGroupTypes []string) ApiBookingReservationsGetRequest {
	r.unitGroupTypes = &unitGroupTypes
	return r
}
func (r ApiBookingReservationsGetRequest) BlockIds(blockIds []string) ApiBookingReservationsGetRequest {
	r.blockIds = &blockIds
	return r
}
func (r ApiBookingReservationsGetRequest) Status(status []string) ApiBookingReservationsGetRequest {
	r.status = &status
	return r
}
func (r ApiBookingReservationsGetRequest) DateFilter(dateFilter string) ApiBookingReservationsGetRequest {
	r.dateFilter = &dateFilter
	return r
}
func (r ApiBookingReservationsGetRequest) From(from time.Time) ApiBookingReservationsGetRequest {
	r.from = &from
	return r
}
func (r ApiBookingReservationsGetRequest) To(to time.Time) ApiBookingReservationsGetRequest {
	r.to = &to
	return r
}
func (r ApiBookingReservationsGetRequest) ChannelCode(channelCode []string) ApiBookingReservationsGetRequest {
	r.channelCode = &channelCode
	return r
}
func (r ApiBookingReservationsGetRequest) Sources(sources []string) ApiBookingReservationsGetRequest {
	r.sources = &sources
	return r
}
func (r ApiBookingReservationsGetRequest) ValidationMessageCategory(validationMessageCategory []string) ApiBookingReservationsGetRequest {
	r.validationMessageCategory = &validationMessageCategory
	return r
}
func (r ApiBookingReservationsGetRequest) ExternalCode(externalCode string) ApiBookingReservationsGetRequest {
	r.externalCode = &externalCode
	return r
}
func (r ApiBookingReservationsGetRequest) TextSearch(textSearch string) ApiBookingReservationsGetRequest {
	r.textSearch = &textSearch
	return r
}
func (r ApiBookingReservationsGetRequest) BalanceFilter(balanceFilter []string) ApiBookingReservationsGetRequest {
	r.balanceFilter = &balanceFilter
	return r
}
func (r ApiBookingReservationsGetRequest) AllFoliosHaveInvoice(allFoliosHaveInvoice bool) ApiBookingReservationsGetRequest {
	r.allFoliosHaveInvoice = &allFoliosHaveInvoice
	return r
}
func (r ApiBookingReservationsGetRequest) PageNumber(pageNumber int32) ApiBookingReservationsGetRequest {
	r.pageNumber = &pageNumber
	return r
}
func (r ApiBookingReservationsGetRequest) PageSize(pageSize int32) ApiBookingReservationsGetRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiBookingReservationsGetRequest) Sort(sort []string) ApiBookingReservationsGetRequest {
	r.sort = &sort
	return r
}
func (r ApiBookingReservationsGetRequest) Expand(expand []string) ApiBookingReservationsGetRequest {
	r.expand = &expand
	return r
}

func (r ApiBookingReservationsGetRequest) Execute() (ReservationListModel, *_nethttp.Response, error) {
	return r.ApiService.BookingReservationsGetExecute(r)
}

/*
 * BookingReservationsGet Returns a list of all reservations, filtered by the specified parameters.
 * Returns a list of all reservations, filtered by the specified parameters. If no parameters are set, returns the entire list.<br>You must have at least one of these scopes: 'reservations.read, reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiBookingReservationsGetRequest
 */
func (a *ReservationApiService) BookingReservationsGet(ctx _context.Context) ApiBookingReservationsGetRequest {
	return ApiBookingReservationsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ReservationListModel
 */
func (a *ReservationApiService) BookingReservationsGetExecute(r ApiBookingReservationsGetRequest) (ReservationListModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReservationListModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.BookingReservationsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.bookingId != nil {
		localVarQueryParams.Add("bookingId", parameterToString(*r.bookingId, ""))
	}
	if r.propertyIds != nil {
		localVarQueryParams.Add("propertyIds", parameterToString(*r.propertyIds, "csv"))
	}
	if r.ratePlanIds != nil {
		localVarQueryParams.Add("ratePlanIds", parameterToString(*r.ratePlanIds, "csv"))
	}
	if r.companyIds != nil {
		localVarQueryParams.Add("companyIds", parameterToString(*r.companyIds, "csv"))
	}
	if r.unitIds != nil {
		localVarQueryParams.Add("unitIds", parameterToString(*r.unitIds, "csv"))
	}
	if r.unitGroupIds != nil {
		localVarQueryParams.Add("unitGroupIds", parameterToString(*r.unitGroupIds, "csv"))
	}
	if r.unitGroupTypes != nil {
		localVarQueryParams.Add("unitGroupTypes", parameterToString(*r.unitGroupTypes, "csv"))
	}
	if r.blockIds != nil {
		localVarQueryParams.Add("blockIds", parameterToString(*r.blockIds, "csv"))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, "csv"))
	}
	if r.dateFilter != nil {
		localVarQueryParams.Add("dateFilter", parameterToString(*r.dateFilter, ""))
	}
	if r.from != nil {
		localVarQueryParams.Add("from", parameterToString(*r.from, ""))
	}
	if r.to != nil {
		localVarQueryParams.Add("to", parameterToString(*r.to, ""))
	}
	if r.channelCode != nil {
		localVarQueryParams.Add("channelCode", parameterToString(*r.channelCode, "csv"))
	}
	if r.sources != nil {
		localVarQueryParams.Add("sources", parameterToString(*r.sources, "csv"))
	}
	if r.validationMessageCategory != nil {
		localVarQueryParams.Add("validationMessageCategory", parameterToString(*r.validationMessageCategory, "csv"))
	}
	if r.externalCode != nil {
		localVarQueryParams.Add("externalCode", parameterToString(*r.externalCode, ""))
	}
	if r.textSearch != nil {
		localVarQueryParams.Add("textSearch", parameterToString(*r.textSearch, ""))
	}
	if r.balanceFilter != nil {
		localVarQueryParams.Add("balanceFilter", parameterToString(*r.balanceFilter, "csv"))
	}
	if r.allFoliosHaveInvoice != nil {
		localVarQueryParams.Add("allFoliosHaveInvoice", parameterToString(*r.allFoliosHaveInvoice, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, "csv"))
	}
	if r.expand != nil {
		localVarQueryParams.Add("expand", parameterToString(*r.expand, "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBookingReservationscountGetRequest struct {
	ctx _context.Context
	ApiService *ReservationApiService
	bookingId *string
	propertyIds *[]string
	ratePlanIds *[]string
	companyIds *[]string
	unitIds *[]string
	unitGroupIds *[]string
	unitGroupTypes *[]string
	blockIds *[]string
	status *[]string
	dateFilter *string
	from *time.Time
	to *time.Time
	channelCode *[]string
	sources *[]string
	validationMessageCategory *[]string
	externalCode *string
	textSearch *string
	balanceFilter *[]string
	allFoliosHaveInvoice *bool
}

func (r ApiBookingReservationscountGetRequest) BookingId(bookingId string) ApiBookingReservationscountGetRequest {
	r.bookingId = &bookingId
	return r
}
func (r ApiBookingReservationscountGetRequest) PropertyIds(propertyIds []string) ApiBookingReservationscountGetRequest {
	r.propertyIds = &propertyIds
	return r
}
func (r ApiBookingReservationscountGetRequest) RatePlanIds(ratePlanIds []string) ApiBookingReservationscountGetRequest {
	r.ratePlanIds = &ratePlanIds
	return r
}
func (r ApiBookingReservationscountGetRequest) CompanyIds(companyIds []string) ApiBookingReservationscountGetRequest {
	r.companyIds = &companyIds
	return r
}
func (r ApiBookingReservationscountGetRequest) UnitIds(unitIds []string) ApiBookingReservationscountGetRequest {
	r.unitIds = &unitIds
	return r
}
func (r ApiBookingReservationscountGetRequest) UnitGroupIds(unitGroupIds []string) ApiBookingReservationscountGetRequest {
	r.unitGroupIds = &unitGroupIds
	return r
}
func (r ApiBookingReservationscountGetRequest) UnitGroupTypes(unitGroupTypes []string) ApiBookingReservationscountGetRequest {
	r.unitGroupTypes = &unitGroupTypes
	return r
}
func (r ApiBookingReservationscountGetRequest) BlockIds(blockIds []string) ApiBookingReservationscountGetRequest {
	r.blockIds = &blockIds
	return r
}
func (r ApiBookingReservationscountGetRequest) Status(status []string) ApiBookingReservationscountGetRequest {
	r.status = &status
	return r
}
func (r ApiBookingReservationscountGetRequest) DateFilter(dateFilter string) ApiBookingReservationscountGetRequest {
	r.dateFilter = &dateFilter
	return r
}
func (r ApiBookingReservationscountGetRequest) From(from time.Time) ApiBookingReservationscountGetRequest {
	r.from = &from
	return r
}
func (r ApiBookingReservationscountGetRequest) To(to time.Time) ApiBookingReservationscountGetRequest {
	r.to = &to
	return r
}
func (r ApiBookingReservationscountGetRequest) ChannelCode(channelCode []string) ApiBookingReservationscountGetRequest {
	r.channelCode = &channelCode
	return r
}
func (r ApiBookingReservationscountGetRequest) Sources(sources []string) ApiBookingReservationscountGetRequest {
	r.sources = &sources
	return r
}
func (r ApiBookingReservationscountGetRequest) ValidationMessageCategory(validationMessageCategory []string) ApiBookingReservationscountGetRequest {
	r.validationMessageCategory = &validationMessageCategory
	return r
}
func (r ApiBookingReservationscountGetRequest) ExternalCode(externalCode string) ApiBookingReservationscountGetRequest {
	r.externalCode = &externalCode
	return r
}
func (r ApiBookingReservationscountGetRequest) TextSearch(textSearch string) ApiBookingReservationscountGetRequest {
	r.textSearch = &textSearch
	return r
}
func (r ApiBookingReservationscountGetRequest) BalanceFilter(balanceFilter []string) ApiBookingReservationscountGetRequest {
	r.balanceFilter = &balanceFilter
	return r
}
func (r ApiBookingReservationscountGetRequest) AllFoliosHaveInvoice(allFoliosHaveInvoice bool) ApiBookingReservationscountGetRequest {
	r.allFoliosHaveInvoice = &allFoliosHaveInvoice
	return r
}

func (r ApiBookingReservationscountGetRequest) Execute() (CountModel, *_nethttp.Response, error) {
	return r.ApiService.BookingReservationscountGetExecute(r)
}

/*
 * BookingReservationscountGet Returns the number of reservations fulfilling the criteria specified in the parameters.
 * If no parameters are set, returns the total count of reservations.<br>You must have at least one of these scopes: 'reservations.read, reservations.manage'.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiBookingReservationscountGetRequest
 */
func (a *ReservationApiService) BookingReservationscountGet(ctx _context.Context) ApiBookingReservationscountGetRequest {
	return ApiBookingReservationscountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return CountModel
 */
func (a *ReservationApiService) BookingReservationscountGetExecute(r ApiBookingReservationscountGetRequest) (CountModel, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CountModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReservationApiService.BookingReservationscountGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/booking/v1/reservations/$count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.bookingId != nil {
		localVarQueryParams.Add("bookingId", parameterToString(*r.bookingId, ""))
	}
	if r.propertyIds != nil {
		localVarQueryParams.Add("propertyIds", parameterToString(*r.propertyIds, "csv"))
	}
	if r.ratePlanIds != nil {
		localVarQueryParams.Add("ratePlanIds", parameterToString(*r.ratePlanIds, "csv"))
	}
	if r.companyIds != nil {
		localVarQueryParams.Add("companyIds", parameterToString(*r.companyIds, "csv"))
	}
	if r.unitIds != nil {
		localVarQueryParams.Add("unitIds", parameterToString(*r.unitIds, "csv"))
	}
	if r.unitGroupIds != nil {
		localVarQueryParams.Add("unitGroupIds", parameterToString(*r.unitGroupIds, "csv"))
	}
	if r.unitGroupTypes != nil {
		localVarQueryParams.Add("unitGroupTypes", parameterToString(*r.unitGroupTypes, "csv"))
	}
	if r.blockIds != nil {
		localVarQueryParams.Add("blockIds", parameterToString(*r.blockIds, "csv"))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, "csv"))
	}
	if r.dateFilter != nil {
		localVarQueryParams.Add("dateFilter", parameterToString(*r.dateFilter, ""))
	}
	if r.from != nil {
		localVarQueryParams.Add("from", parameterToString(*r.from, ""))
	}
	if r.to != nil {
		localVarQueryParams.Add("to", parameterToString(*r.to, ""))
	}
	if r.channelCode != nil {
		localVarQueryParams.Add("channelCode", parameterToString(*r.channelCode, "csv"))
	}
	if r.sources != nil {
		localVarQueryParams.Add("sources", parameterToString(*r.sources, "csv"))
	}
	if r.validationMessageCategory != nil {
		localVarQueryParams.Add("validationMessageCategory", parameterToString(*r.validationMessageCategory, "csv"))
	}
	if r.externalCode != nil {
		localVarQueryParams.Add("externalCode", parameterToString(*r.externalCode, ""))
	}
	if r.textSearch != nil {
		localVarQueryParams.Add("textSearch", parameterToString(*r.textSearch, ""))
	}
	if r.balanceFilter != nil {
		localVarQueryParams.Add("balanceFilter", parameterToString(*r.balanceFilter, "csv"))
	}
	if r.allFoliosHaveInvoice != nil {
		localVarQueryParams.Add("allFoliosHaveInvoice", parameterToString(*r.allFoliosHaveInvoice, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v MessageItemCollection
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
